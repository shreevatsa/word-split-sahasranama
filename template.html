<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vishnu Sahasranama</title>
  <!-- <script src="https://cdn.tailwindcss.com/3.4.17"></script> -->
  <style>
    /* [[[cog
    print(open('dist/tailwind.3.4.17.css').read(), end='')
    ]]] */
    /* [[[end]]] */
  </style>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
  <main class="min-h-screen container mx-auto p-4 md:p-8">
    <header class="text-center mb-8">
      <h1 class="text-3xl md:text-4xl font-bold">Vishnu Sahasranama</h1>
      <p class="text-gray-600 dark:text-gray-400">Hover on or tap coloured segments for meanings.</p>
      <p class="text-sm text-gray-500 dark:text-gray-400 mb-2">
        Everything below is based on the text and translation from
        <a href="https://www.swami-krishnananda.org/vishnu/vishnu_1.html" class="text-blue-600 underline underline-offset-2 hover:decoration-2 hover:text-blue-700
                 visited:text-purple-600 focus-visible:outline focus-visible:outline-2
                 focus-visible:outline-offset-2 focus-visible:outline-current
                 dark:text-sky-400 dark:hover:text-sky-300 dark:visited:text-violet-400">the website of Swami Krishnananda</a>.
      </p>
    </header>

    <!-- Cards get injected here; we also delegate events from this element -->
    <div id="app"></div>

    <footer class="text-center text-sm text-gray-500 dark:text-gray-400 mt-8">
      <p>
        Single HTML file with inlined dependencies. Source code at
        <a href="https://github.com/shreevatsa/word-split-sahasranama" class="text-blue-600 underline underline-offset-2 hover:decoration-2 hover:text-blue-700
                 visited:text-purple-600 focus-visible:outline focus-visible:outline-2
                 focus-visible:outline-offset-2 focus-visible:outline-current
                 dark:text-sky-400 dark:hover:text-sky-300 dark:visited:text-violet-400">https://github.com/shreevatsa/word-split-sahasranama</a>.
      </p>
    </footer>
  </main>

  <!-- One persistent tooltip (outside main so we never overwrite it) -->
  <div id="word-meaning-tip" role="tooltip" aria-hidden="true" hidden class="fixed bg-gray-800 text-white dark:bg-gray-700 dark:border dark:border-gray-600
              text-sm rounded-md px-3 py-2 shadow-lg pointer-events-none whitespace-normal
              w-max min-w-[12rem] break-words z-50"></div>

  <script>
    /* [[[cog
    print(open('data.js').read(), end='')
    ]]] */
    // [[[end]]]

    // --- constants / state ---
    const colors = ["#3b82f6", "#ef4444", "#10b981", "#f97316", "#8b5cf6", "#d946ef", "#14b8a6", "#f59e0b", "#6366f1", "#ec4899"];
    const tip = document.getElementById('word-meaning-tip');
    const app = document.getElementById('app'); // single element for injection + delegation
    const COARSE_POINTER = window.matchMedia && matchMedia('(pointer: coarse)').matches;
    let idx = 0, current = null, raf = 0;

    // --- rendering ---
    function word(display, meaning, n) {
      const c = colors[idx++ % colors.length];
      const escHtml = s => String(s).replace(/[&<]/g, m => ({ '&': '&amp;', '<': '&lt;' }[m]));    // text node escape
      const escAttr = s => String(s).replace(/[&"]/g, m => ({ '&': '&amp;', '"': '&quot;' }[m]));  // double-quoted attr escape
      // Keep strictly single-line, as container uses `whitespace-pre-wrap`
      return `<span class="word font-bold cursor-pointer" tabindex="0" style="color:${c}"
                data-meaning="${escAttr(meaning)}" data-n="${n}">${escHtml(display)}</span>`;
    }

    function render() {
      idx = 0;
      const cards = data.map(s => {
        const lines = s.lines.map(line => line.map(part => Array.isArray(part)
          ? word(part[0], part[1], part[2])
          : `<span>${part}</span>`).join('')).join('<br>');
        return `
          <section class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow rounded-xl p-6 md:p-8 mb-6">
            <p class="text-2xl md:text-3xl text-gray-700 dark:text-gray-300 font-serif whitespace-pre-line leading-relaxed" lang="sa-Deva" translate="no">${s.dev}</p>
            <div class="mt-3 text-lg md:text-xl text-gray-600 dark:text-gray-400 font-sans whitespace-pre-wrap leading-relaxed" lang="sa-Latn" translate="no">${lines}</div>
          </section>`;
      }).join('');
      app.innerHTML = cards;
    }

    // --- tooltip logic ---
    function positionTo(el) {
      const margin = COARSE_POINTER ? 12 : 8;
      const vv = window.visualViewport;
      const vx = vv ? vv.offsetLeft : 0;
      const vy = vv ? vv.offsetTop : 0;
      const vw = vv ? vv.width : window.innerWidth;
      const vh = vv ? vv.height : window.innerHeight;

      tip.style.maxWidth = Math.min(640, vw - margin * 2) + 'px';
      tip.hidden = false; // show to measure

      const r = tip.getBoundingClientRect();
      const a = el.getBoundingClientRect();

      let left = a.left + a.width / 2 - r.width / 2;
      let top = a.top - r.height - margin;

      left = Math.max(margin, Math.min(left, vw - r.width - margin));
      if (top < margin) top = a.bottom + margin;
      if (top + r.height > vh - margin) top = Math.max(margin, vh - r.height - margin);

      tip.style.left = (vx + left) + 'px';
      tip.style.top = (vy + top) + 'px';
    }

    function openTip(w) {
      current = w;
      tip.textContent = `${w.dataset.meaning} (${w.dataset.n})`;
      positionTo(w);
      tip.hidden = false;
      tip.setAttribute('aria-hidden', 'false');
      w.setAttribute('aria-describedby', 'word-meaning-tip');
    }

    function hideTip() {
      if (current) current.removeAttribute('aria-describedby');
      tip.hidden = true;
      tip.setAttribute('aria-hidden', 'true');
      current = null;
    }

    const reflowToCurrent = () => {
      if (!current) return;
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => positionTo(current));
    };

    // --- events (delegate from #app) ---
    app.addEventListener('pointerover', e => {
      const w = e.target.closest('.word');
      if (w && current !== w) openTip(w);
    });

    app.addEventListener('pointerout', e => {
      if (!e.currentTarget.contains(e.relatedTarget)) { hideTip(); return; }
      const w = e.target.closest('.word');
      if (w && w === current && !w.contains(e.relatedTarget)) hideTip();
    });

    app.addEventListener('pointerdown', e => {
      const w = e.target.closest('.word');
      if (!w) return;
      e.stopPropagation();
      openTip(w);
    });

    document.addEventListener('pointerdown', hideTip);

    addEventListener('scroll', reflowToCurrent, { capture: true, passive: true });
    addEventListener('resize', reflowToCurrent);
    if (window.visualViewport) {
      visualViewport.addEventListener('resize', reflowToCurrent);
      visualViewport.addEventListener('scroll', reflowToCurrent);
    }

    app.addEventListener('focusin', e => { const w = e.target.closest('.word'); if (w) openTip(w); });
    app.addEventListener('focusout', hideTip);
    document.addEventListener('keydown', e => { if (e.key === 'Escape') hideTip(); });
    addEventListener('blur', hideTip);
    document.addEventListener('visibilitychange', () => { if (document.hidden) hideTip(); });

    // Render immediately (script is after DOM)
    render();
  </script>
</body>

</html>
