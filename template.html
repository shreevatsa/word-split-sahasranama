<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vishnu Sahasranama</title>
  <!-- <script src="https://cdn.tailwindcss.com/3.4.17"></script> -->
  <!-- Pasting the entire ~400K of Tailwind here, sorry. -->
  <script>
    /* [[[cog
     import urllib.request
     print(urllib.request.urlopen('https://cdn.tailwindcss.com/3.4.17').read().decode('utf-8'))
    ]]] */
    // [[[end]]]
  </script>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200">
  <main id="app" class="min-h-screen container mx-auto p-4 md:p-8"></main>

  <script>
    /* [[[cog
    print(open('data.js').read(), end='')
    ]]] */
    // [[[end]]]
    // Color cycle
    const colors = ["#3b82f6", "#ef4444", "#10b981", "#f97316", "#8b5cf6", "#d946ef", "#14b8a6", "#f59e0b", "#6366f1", "#ec4899"];
    let idx = 0;
    let currentOpen = null; // keep at most one tooltip visible

    // IMPORTANT: no newlines/extra spaces inside the returned HTML â€” because the
    // container uses `whitespace-pre-wrap`, any whitespace in the template would
    // render as visible line breaks. So keep this strictly single-line.
    function word(display, meaning, n) {
      const c = colors[idx++ % colors.length];
      const esc = s => String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      return `<span class="relative inline-block tooltip-wrapper"><span class="font-bold" style="color:${c};cursor:pointer;">${display}</span><span class="tooltip-text absolute -top-2 left-1/2 -translate-x-1/2 bg-gray-800 text-white dark:bg-gray-700 dark:border dark:border-gray-600 text-sm rounded-md px-3 py-2 shadow-lg opacity-0 invisible group-hover:opacity-100 group-hover:visible transition pointer-events-none whitespace-normal w-max min-w-[12rem] break-words z-50" style="max-width:min(40rem,calc(100vw - 16px));">${esc(meaning)} (${n})</span></span>`;
    }

    // Position tooltip using fixed viewport coordinates to avoid clipping.
    function positionTooltipFixed(tip, anchorRect) {
      const margin = (window.matchMedia && matchMedia('(pointer: coarse)').matches) ? 12 : 8; // a bit more room on mobile
      // Use visual viewport on mobile to account for zoom/pinch and card-width viewport
      const vv = window.visualViewport;
      const vWidth = vv ? vv.width : window.innerWidth;
      const vHeight = vv ? vv.height : window.innerHeight;

      tip.style.position = 'fixed';
      tip.style.maxWidth = Math.min(640, vWidth - margin * 2) + 'px';
      tip.classList.remove('opacity-0', 'invisible');

      // Measure after making visible
      const rect = tip.getBoundingClientRect();

      // Default: above, centered
      let left = anchorRect.left + anchorRect.width / 2 - rect.width / 2;
      let top = anchorRect.top - rect.height - margin;

      // Horizontal clamp within visual viewport
      left = Math.max(margin, Math.min(left, vWidth - rect.width - margin));

      // If not enough room above, place below; also keep within bottom edge
      if (top < margin) top = anchorRect.bottom + margin;
      if (top + rect.height > vHeight - margin) top = Math.max(margin, vHeight - rect.height - margin);

      tip.style.left = left + 'px';
      tip.style.top = top + 'px';
      tip.style.transform = 'none';
    }
    function showTooltip(wrapper) {
      const tip = wrapper.querySelector('.tooltip-text');
      if (!tip) return;
      const a = wrapper.getBoundingClientRect();
      positionTooltipFixed(tip, a);
      wrapper.dataset.open = '1';
    }
    function hideTooltip(wrapper) {
      const tip = wrapper.querySelector('.tooltip-text');
      if (!tip) return;
      tip.classList.add('opacity-0', 'invisible');
      tip.style.left = tip.style.top = tip.style.transform = tip.style.position = '';
      delete wrapper.dataset.open;
    }

    function attachHandlers() {
      // Delegate for performance (works for all words)
      const app = document.getElementById('app');
      app.addEventListener('mouseenter', e => {
        const w = e.target.closest('.tooltip-wrapper');
        if (!w) return;
        if (currentOpen && currentOpen !== w) hideTooltip(currentOpen);
        requestAnimationFrame(() => { requestAnimationFrame(() => { showTooltip(w); currentOpen = w; }); });
      }, true);
      app.addEventListener('mousemove', e => {
        const w = e.target.closest('.tooltip-wrapper');
        if (w) {
          if (currentOpen && currentOpen !== w) hideTooltip(currentOpen);
          showTooltip(w);
          currentOpen = w;
        } else if (currentOpen) {
          hideTooltip(currentOpen);
          currentOpen = null;
        }
      });
      app.addEventListener('mouseleave', e => {
        if (currentOpen) { hideTooltip(currentOpen); currentOpen = null; }
      }, true);
      // Touch/click
      app.addEventListener('touchstart', e => {
        const w = e.target.closest('.tooltip-wrapper');
        if (!w) return; e.stopPropagation();
        if (currentOpen && currentOpen !== w) hideTooltip(currentOpen);
        showTooltip(w); currentOpen = w;
      }, { passive: true });
      app.addEventListener('click', e => {
        const w = e.target.closest('.tooltip-wrapper');
        if (!w) return; e.stopPropagation();
        if (currentOpen && currentOpen !== w) hideTooltip(currentOpen);
        showTooltip(w); currentOpen = w;
        if (!w) return; e.stopPropagation(); showTooltip(w);
      });
      document.addEventListener('click', () => {
        document.querySelectorAll('.tooltip-wrapper').forEach(hideTooltip);
        currentOpen = null;
      });
      document.addEventListener('touchstart', () => {
        document.querySelectorAll('.tooltip-wrapper').forEach(hideTooltip);
        currentOpen = null;
      }, { passive: true });
      window.addEventListener('resize', () => {
        document.querySelectorAll('.tooltip-wrapper').forEach(hideTooltip);
        currentOpen = null;
      });
      // On mobile zoom/pan, visual viewport changes; update/open tooltip position
      if (window.visualViewport) {
        visualViewport.addEventListener('resize', () => {
          if (currentOpen) showTooltip(currentOpen);
        });
        visualViewport.addEventListener('scroll', () => {
          if (currentOpen) showTooltip(currentOpen);
        });
      }
    }

    function render() {
      idx = 0;
      const cards = data.map(s => {
        const lines = s.lines.map(line => line.map(part => Array.isArray(part)
          ? word(part[0], part[1], part[2])
          : `<span>${part}</span>`).join('')).join('<br>');
        return `
          <section class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 shadow rounded-xl p-6 md:p-8 mb-6">
            <p class="text-2xl md:text-3xl text-gray-700 dark:text-gray-300 font-serif whitespace-pre-line leading-relaxed" lang="sa">${s.dev}</p>
            <div class="mt-3 text-lg md:text-xl text-gray-600 dark:text-gray-400 font-sans whitespace-pre-wrap leading-relaxed" lang="sa-Latn">${lines}</div>
          </section>`;
      }).join('');

      document.getElementById('app').innerHTML = `
        <header class="text-center mb-8">
          <h1 class="text-3xl md:text-4xl font-bold">Vishnu Sahasranama</h1>
          <p class="text-gray-600 dark:text-gray-400">Hover on or tap coloured segments for meanings.</p>
          <p class="text-sm text-gray-500 dark:text-gray-400 mb-2">Everything below is based on the text and translation from <a href="https://www.swami-krishnananda.org/vishnu/vishnu_1.html">the website of Swami Krishnananda</a>.</p>
        </header>
        ${cards}
        <footer class="text-center text-sm text-gray-500 dark:text-gray-400 mt-8"><p>Single-file, Tailwind CDN, auto color cycling</p><p>Source code at &lt;...&gt;</p></footer>`;

      attachHandlers();
    }

    document.addEventListener('DOMContentLoaded', render);
  </script>
</body>

</html>
